
import cv2
from PIL import Image
import numpy

# TODO Finne ut hvordan man endrer parameter i HOGDescriptor

class NeuralNet():

    def __init__(self):
        # Initierer HoG variabler. Initierer parameterisering av HoG.
        self.HOGde = cv2.HOGDescriptor((32, 64), (32,32), (16,16), (8,8), 9)

    def ImportTrening(self,antallPos,antallNeg):
        # Maksimum treningsdata er 687 positive og 836 negative. Utforer HoG og samler i matriser
        # Treningsdata har default vindusstorrelse paa bilder: 32x64.
        # Anvender HoG blokkstorrelse paa 4x4 og cellestorrelse 8x8.
        # Tilsvarer 432 features per bilde

        # Lager tomme matriser
        self.posTrening = numpy.empty((1,432))
        self.negTrening = numpy.empty((1,432))

        # Bildesti til treningsdata
        self.sti = "C:\Users\Vegard\Documents\Python\Ansikt_Database"

        for pos in range(1,antallPos):
            # Laster inn bilder med fjes og utforer HoG. Endrer storrelse med resize(bredde,hoyde)
            bildeNavnPos = "\PosTrening (" + str(pos) + ").jpg"
            bildeSti = str(self.sti+""+bildeNavnPos)
            bildePos = Image.open(bildeSti)
            bildePosSkalert = bildePos.resize((32,64), Image.ANTIALIAS)
            bildePosMat = numpy.asarray(bildePosSkalert)
            self.posTrening = numpy.vstack([self.posTrening,(self.HOGde.compute(bildePosMat, winStride=(32,64), padding=(0,0))).T])

        for neg in range(1,antallNeg):
            # Laster inn bilder uten fjes og utforer HoG. Endrer storrelse med resize(bredde,hoyde)
            bildeNavnNeg = "\NegTrening (" + str(neg) + ").jpg"
            bildeSti = str(self.sti+""+bildeNavnNeg)
            bildeNeg = Image.open(bildeSti)
            bildeNegSkalert = bildeNeg.resize((32,64), Image.ANTIALIAS)
            bildeNegMat = numpy.asarray(bildeNegSkalert)
            self.negTrening = numpy.vstack([self.negTrening,(self.HOGde.compute(bildeNegMat, winStride=(32,64), padding=(0,0))).T])

        return self.posTrening
    

    def NeuralNetverk(self,nh,antallInput):

        # TODO: Skille Neuralt nettverk i egen klasse.
        # Lager et neuralt nettverk.
        # antallInput = antall features i inngangsvektoren.
        # nh = antall gjemte noder i nettverket.

        # Omraadet vektene skal ligge mellom og antall utganger.
        self.initVekt = 1/math.sqrt(nh)
        self.antallKlasser = 2

        # Lager matriser for vekter.
        # ItH = Input to Hidden, HtOK1/2 = Hidden to Output Klasse 1/2.
        self.vektItH = numpy.empty((nh, antallInput))
        self.vektHtOK1 = numpy.empty((nh, 2))
        self.vektHtOK2 = numpy.empty((nh, 2))

        # Lager vektorer for ItH og HtO Bias.
        self.ItHBias = numpy.empty((nh,1))
        self.HtOBias = numpy.empty((nh,1))

        # Fyller inn verdier i nodevekt og bias.
        for rad in range(0, nh):

            # Fyller Bias med vekslende tall -0.5 og 0.5.
            self.ItHBias[rad,0] = 0.5*math.pow(-1,rad)
            self.HtOBias[rad,0] = 0.5*math.pow(-1,rad)

            # Lager nodevekt i omraadet -1/sqrt(nh)<noder<1/sqrt(nh).
            for kol in range(0,antallInput):
                self.vektItH[rad, kol] = (random.randrange(-100,100) * self.initVekt)/100

                if kol <= self.antallKlasser-1:
                    self.vektHtOK1[rad, kol] = (random.randrange(-100,100) * self.initVekt)/100
                    self.vektHtOK2[rad, kol] = (random.randrange(-100,100) * self.initVekt)/100



    def forwardComputation(self):
        # TODO: Implementere flere aktiveringsfunksjoner?
        # Regner ut forward computation for det neurale nettverket.
        # Bruker aktiveringsfunksjon

        # Lager en "dummy" inngangsvekor. Vil tilsvare signalet
        self.inngangsVektor = numpy.ones(self.nh,1)

        # Lager utgangsvektor fra den gjemte noden
        self.utgangsVektorHidden = numpy.zeros(self.nh,1)

        # Finner "net" for alle nodene
        self.netHidden = self.vektItH*self.inngangsvektor + self.ItHBias

        # Finner utgangen til den gjemte noden. Bruker aktiveringsfunkjson paa formen 1/(1+e^(net))
        for node in range(0,self.nh):
            self.utgangsVektorHidden[node,0] = 1/(1 + math.exp(self.netHidden[self.nh,0]))


